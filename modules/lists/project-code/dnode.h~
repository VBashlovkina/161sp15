/*** 
 * dnode.h Doubly Linked Lists specification for the module 5 project
 *
 * Author: David Cowden
 * First version:  July-August 2011
 * Major revision: 4 August 2011
 * Revised with simplifications:  November 13, 2011  by Henry M. Walker
 * 
 */

/* 
 * Define the structure (frequency and duration) for a note.
 */
typedef struct Note {
  int freq;
  double time;
} Note;

/* - Doubly linked list node with fields for 
      - note information
      - id to simplify reference to a node
*/
struct dnode {
  Note note_data;
  int id;
  struct dnode * next;
  struct dnode * prev;
};

typedef struct dnode * dnode_t;

/*********************************************************
 * Procedure prototypes for dnodes   
 *********************************************************/

/* create a new dnode (not a dnode_t)
 * set next and prev fields to NULL
 * return a pointer to new node
 */
dnode_t createNode (void);

/* set the contents of node's note_data field to data */
/* pre-condition:  node is not NULL */
void setNodeNote (dnode_t node, Note data);

/* set the contents of node's id field to id */
/* pre-condition:  node is not NULL */
void setNodeID (dnode_t node, int id);

/* insert node into the list after node after. node is returned */
void insertNodeAfter (dnode_t node, dnode_t after);

/* insert node into the list before node before. node is returned */
void insertNodeBefore (dnode_t node, dnode_t before);

/* remove node from list but do not free node. node is returned */
dnode_t removeNode (dnode_t node);

/* delete node (free its memory) */
void deleteNode (dnode_t node);
/* ONLY DELETE nodes that have already been REMOVED from your list (with 
 * removeNode) */
/* WARNING, if node is your only reference to your list your entire list 
 * will be lost */

/* search the entire list for a node with an id that matches id */
dnode_t findNodeByID (dnode_t node, int id);

/* return the next node */
/* post-condition:  if node is not NULL, return pointer to next node
                    otherwise, return NULL
*/
dnode_t nextNode (dnode_t node);

/* return the previous node */
/* post-condition:  if node is not NULL, return pointer to previous node
                    otherwise, return NULL
*/
dnode_t prevNode (dnode_t node);

/* return the node's id */
/* pre-condition:  node is not NULL */
int getNodeID (dnode_t node);

/* return the node's node_data */
/* pre-condition:  node is not NULL */
Note getNodeNote (dnode_t node);

/************************************************************
 * Implementations of the dnode functions
 * The project consists of adding correct details to the following
 * functions
 ************************************************************/
/* create a new dnode (not a dnode_t)
 * set next and prev fields to NULL
 * return a pointer to new node
 */
dnode_t createNode (void)
{
  dnode_t ptr = malloc(sizeof(struct dnode));
  ptr->next = NULL;
  ptr->prev = NULL;
  return ptr;
}

/* set the contents of node's note_data field to data */
/* pre-condition:  node is not NULL */
void setNodeNote (dnode_t node, Note data)
{
  (node->note_data).freq = data.freq;
  (node->note_data).time = data.time;
}

/* set the contents of node's id field to id */
/* pre-condition:  node is not NULL */
void setNodeID (dnode_t node, int id)
{
  node->id = id;
}

/* insert node into the list after node after. */
void insertNodeAfter (dnode_t node, dnode_t after)
{
  /* pre-condition:  node and after are non NULL */
  if (node == NULL)
    return;
  if (after == NULL)
    return;

  /* link node into list */
  node->next = after->next;
  node->prev = after;
  if (after->next != NULL)
    (after->next)->prev = node;
  after->next = node;
}

/* insert node into the list before node before. */
void insertNodeBefore (dnode_t node, dnode_t before)
{
  /* pre-condition:  node and before are non NULL */
  if (node == NULL)
    return;
  if (before == NULL)
    return;

  /* link node into list */
  node->prev = before->prev;
  node->next = before;
  if (before->prev != NULL)
    (before->prev)->next = node;
  before->prev = node;
}

/* remove node from list but do not free node. node is returned */
dnode_t removeNode (dnode_t node)
{
  if (node == NULL)
    return NULL;
  if (node->next != NULL)
    (node->next)->prev = node->prev;
  if (node->prev != NULL)
    (node->prev)->next = node->next;
  return node;
}

/* delete node (free its memory) */
/* WARNING, if node is your only reference to your list your entire list 
 * will be lost */
void deleteNode (dnode_t node)
{
  /* first remove node from list */
  removeNode (node);
  free (node);
}

/* search the entire list for a node with an id that matches id */
dnode_t findNodeByID (dnode_t node, int id)
{
  if (node == NULL)
    return NULL;

  /* first move to start of list */
  while (node->prev != NULL)
    node = node->prev;

  /* traverse list from front to back */
  while (node != NULL)
    {
      if (node->id == id)
        return node;
      node = node->next;
    }

  /* id not found */
  return NULL;
}

/* return the next node */
/* post-condition:  if node is not NULL, return pointer to next node
                    otherwise, return NULL
*/
dnode_t nextNode (dnode_t node)
{
  if (node == NULL)
    return NULL;
  else 
    return node->next;
}

/* return the previous node */
/* post-condition:  if node is not NULL, return pointer to previous node
                    otherwise, return NULL
*/
dnode_t prevNode (dnode_t node)
{
  if (node == NULL)
    return NULL;
  else 
    return node->prev;
}

/* return the node's id */
/* pre-condition:  node is not NULL */
int getNodeID (dnode_t node)
{
  if (node == NULL)
    return 0;
  else
    return node->id;
}

/* return the node's note_data */
/* pre-condition:  node is not NULL */
Note getNodeNote (dnode_t node)
{ 
  
  if (node == NULL)
    {
      /* the following code constructs a note and returns it,
       * so program will compile */
      Note * data = malloc(sizeof(Note));
        data->freq=880;
        data->time=0.75;
        return *data;
    }
  else
    return node->note_data;
}

